```bash
IDEMPOTENCY IN AWS LAMBDA (PRACTICAL & IMPORTANT)

WHAT IS IDEMPOTENCY?
- Idempotency means performing the SAME operation multiple times
  produces the SAME result as performing it once
- In Lambda, it prevents duplicate processing during retries

WHY IDEMPOTENCY IS CRITICAL IN LAMBDA
- Asynchronous invocations are retried automatically
- Network failures can cause duplicate events
- Partial failures may re-trigger the same request
- Without idempotency:
  - Duplicate records
  - Double charges
  - Data corruption

WHEN DUPLICATES HAPPEN
- Async Lambda retries (S3, EventBridge, SNS)
- Client retries (timeouts, network errors)
- Step Functions retries
- At-least-once delivery event sources

NON-IDEMPOTENT EXAMPLE (BAD)

def lambda_handler(event, context):
    create_order(event["order_id"])

If invoked twice → TWO orders are created

IDEMPOTENT CORE IDEA
- Every request must have a UNIQUE idempotency key
- Process the request ONLY ONCE per key
- Safely ignore or return on duplicates

COMMON IDEMPOTENCY KEYS
- order_id
- request_id
- event_id
- UUID generated by client
- context.aws_request_id (not ideal for retries)

PRACTICAL DEMO – USING DYNAMODB

TABLE DESIGN
- Table name: IdempotencyTable
- Partition key: idempotency_key (string)
- TTL attribute: expiry_time

IDEMPOTENT LAMBDA CODE (RECOMMENDED)

import boto3
import time
from botocore.exceptions import ClientError

dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table("IdempotencyTable")

def lambda_handler(event, context):
    key = event["idempotency_key"]
    ttl = int(time.time()) + 3600  # 1 hour TTL

    try:
        table.put_item(
            Item={
                "idempotency_key": key,
                "expiry_time": ttl
            },
            ConditionExpression="attribute_not_exists(idempotency_key)"
        )
    except ClientError as e:
        if e.response["Error"]["Code"] == "ConditionalCheckFailedException":
            return "Already processed"
        else:
            raise

    process_order(event)
    return "Processed successfully"

WHAT THIS DOES
- First request:
  - Key stored
  - Business logic runs
- Duplicate request:
  - Condition fails
  - Logic is skipped
- TTL automatically cleans old keys

IMPORTANT IDEMPOTENCY RULES
- Perform idempotency check BEFORE business logic
- Store key BEFORE side effects
- Always use TTL to avoid table growth

AWS-MANAGED IDEMPOTENCY (OPTIONAL)
- AWS Lambda Powertools provides idempotency utilities
- Handles:
  - Storage
  - TTL
  - Serialization
  - Error handling

WHEN IDEMPOTENCY IS REQUIRED
- Payments
- Order creation
- File processing
- Async workloads
- External API calls

WHEN IT MAY NOT BE REQUIRED
- Read-only operations
- Pure calculations
- Already-idempotent downstream systems

FINAL ONE-LINE TAKEAWAY
Idempotency ensures a Lambda request is processed ONCE,
even if AWS invokes it multiple times.
```

```bash
COMPLETE PRACTICAL DEMO – IDEMPOTENCY IN AWS LAMBDA (END-TO-END)

GOAL OF THIS PRACTICAL
- Demonstrate duplicate Lambda invocations
- Show how duplicates cause problems
- Fix the issue using idempotency with DynamoDB
- Observe correct behavior with retries

============================================================

STEP 1: CREATE DYNAMODB TABLE (IDEMPOTENCY STORE)

Table name:
IdempotencyTable

Partition key:
idempotency_key (String)

TTL attribute:
expiry_time (Number)

Enable TTL:
- Attribute name: expiry_time
- Purpose: auto-delete old keys

------------------------------------------------------------

STEP 2: CREATE A LAMBDA FUNCTION

Runtime:
Python 3.10

Timeout:
10 seconds

Permissions:
Attach IAM policy allowing:
- dynamodb:PutItem
- dynamodb:GetItem
- dynamodb:DescribeTable

------------------------------------------------------------

STEP 3: NON-IDEMPOTENT VERSION (BAD DESIGN)

This version WILL break when retries happen.

Code:

import time

def lambda_handler(event, context):
    print("Processing order:", event["order_id"])
    time.sleep(2)
    print("Order created:", event["order_id"])

Problem:
- If Lambda is retried
- Order is created AGAIN

------------------------------------------------------------

STEP 4: TRIGGER DUPLICATE INVOCATIONS

Use ASYNCHRONOUS invocation:

aws lambda invoke \
  --function-name my-function \
  --invocation-type Event \
  --payload '{"order_id":"ORD-123"}' \
  response.json

Run the same command MULTIPLE times.

Result:
- Same order processed multiple times ❌

------------------------------------------------------------

STEP 5: IDEMPOTENT VERSION (FIXED DESIGN)

Replace Lambda code with:

import boto3
import time
from botocore.exceptions import ClientError

dynamodb = boto3.resource("dynamodb")
table = dynamodb.Table("IdempotencyTable")

def lambda_handler(event, context):
    key = event["order_id"]
    ttl = int(time.time()) + 3600

    try:
        table.put_item(
            Item={
                "idempotency_key": key,
                "expiry_time": ttl
            },
            ConditionExpression="attribute_not_exists(idempotency_key)"
        )
    except ClientError as e:
        if e.response["Error"]["Code"] == "ConditionalCheckFailedException":
            print("Duplicate event detected. Skipping.")
            return "Duplicate ignored"
        else:
            raise

    print("Processing order:", key)
    time.sleep(2)
    print("Order created:", key)

    return "Order processed"

------------------------------------------------------------

STEP 6: TEST IDEMPOTENCY (IMPORTANT STEP)

Invoke the SAME event again:

aws lambda invoke \
  --function-name my-function \
  --invocation-type Event \
  --payload '{"order_id":"ORD-123"}' \
  response.json

Repeat multiple times.

EXPECTED RESULT:
- First invocation → order processed
- All duplicates → skipped
- NO duplicate orders created

------------------------------------------------------------

STEP 7: FORCE FAILURE TO TEST RETRIES

Modify Lambda temporarily:

def lambda_handler(event, context):
    raise Exception("Simulated failure")

Invoke asynchronously.

OBSERVE:
- AWS retries automatically
- Same event ID reused
- Idempotency logic protects from duplication

------------------------------------------------------------

STEP 8: VERIFY DYNAMODB TABLE

You will see:
- One record per unique idempotency_key
- expiry_time set
- Old records removed automatically by TTL

------------------------------------------------------------

WHAT THIS PRACTICAL PROVES

- Async Lambda delivers events AT LEAST ONCE
- Retries WILL happen
- Idempotency is REQUIRED for safety
- DynamoDB conditional writes prevent duplicates
- TTL keeps storage clean

------------------------------------------------------------

COMMON MISTAKES TO AVOID

- Using context.aws_request_id as idempotency key
- Writing business logic BEFORE idempotency check
- Forgetting TTL
- Assuming Lambda runs only once

------------------------------------------------------------

REAL-WORLD USE CASES

- Payments
- Order creation
- Email sending
- File processing
- External API calls

------------------------------------------------------------

FINAL ONE-LINE TAKEAWAY

Async Lambda can run the SAME event multiple times.
Idempotency guarantees it is PROCESSED ONLY ONCE.
